
build/PingPongDelay.elf:     file format elf32-littlearm


Disassembly of section .text:

20019040 <_text_start>:
20019040:	4770      	bx	lr

20019042 <_hook_resume>:
20019042:	4770      	bx	lr
20019044:	4770      	bx	lr

20019046 <_hook_suspend>:
20019046:	4770      	bx	lr
20019048:	4770      	bx	lr

2001904a <_entry>:
2001904a:	4b10      	ldr	r3, [pc, #64]	; (2001908c <_entry+0x42>)
2001904c:	4a10      	ldr	r2, [pc, #64]	; (20019090 <_entry+0x46>)
2001904e:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
20019052:	4688      	mov	r8, r1
20019054:	4607      	mov	r7, r0
20019056:	2100      	movs	r1, #0
20019058:	4293      	cmp	r3, r2
2001905a:	d002      	beq.n	20019062 <_entry+0x18>
2001905c:	f803 1f01 	strb.w	r1, [r3, #1]!
20019060:	e7fa      	b.n	20019058 <_entry+0xe>
20019062:	4b0c      	ldr	r3, [pc, #48]	; (20019094 <_entry+0x4a>)
20019064:	4c0c      	ldr	r4, [pc, #48]	; (20019098 <_entry+0x4e>)
20019066:	1ae4      	subs	r4, r4, r3
20019068:	10a4      	asrs	r4, r4, #2
2001906a:	2500      	movs	r5, #0
2001906c:	461e      	mov	r6, r3
2001906e:	42a5      	cmp	r5, r4
20019070:	d005      	beq.n	2001907e <_entry+0x34>
20019072:	f856 3025 	ldr.w	r3, [r6, r5, lsl #2]
20019076:	b103      	cbz	r3, 2001907a <_entry+0x30>
20019078:	4798      	blx	r3
2001907a:	3501      	adds	r5, #1
2001907c:	e7f7      	b.n	2001906e <_entry+0x24>
2001907e:	4641      	mov	r1, r8
20019080:	4638      	mov	r0, r7
20019082:	f000 f815 	bl	200190b0 <_hook_init>
20019086:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
2001908a:	bf00      	nop
2001908c:	20019207 	.word	0x20019207
20019090:	20019223 	.word	0x20019223
20019094:	20019040 	.word	0x20019040
20019098:	20019040 	.word	0x20019040

2001909c <_Z9setMemoryv>:
  Give the s_delay_ram to s_delay object, instantiate variables
*/

void setMemory()
{
  for (int i = 0; i < BUF_SIZE; i++)
2001909c:	4a03      	ldr	r2, [pc, #12]	; (200190ac <_Z9setMemoryv+0x10>)
/*
  Give the s_delay_ram to s_delay object, instantiate variables
*/

void setMemory()
{
2001909e:	2300      	movs	r3, #0
  for (int i = 0; i < BUF_SIZE; i++)
    delay[i] = 0.f;
200190a0:	2100      	movs	r1, #0
200190a2:	f843 1b04 	str.w	r1, [r3], #4
  Give the s_delay_ram to s_delay object, instantiate variables
*/

void setMemory()
{
  for (int i = 0; i < BUF_SIZE; i++)
200190a6:	4293      	cmp	r3, r2
200190a8:	d1fb      	bne.n	200190a2 <_Z9setMemoryv+0x6>
    delay[i] = 0.f;
}
200190aa:	4770      	bx	lr
200190ac:	000cd140 	.word	0x000cd140

200190b0 <_hook_init>:

void DELFX_INIT(uint32_t platform, uint32_t api)
{
200190b0:	b508      	push	{r3, lr}
  setMemory();
200190b2:	f7ff fff3 	bl	2001909c <_Z9setMemoryv>
  s_mix = .5f;
200190b6:	4b02      	ldr	r3, [pc, #8]	; (200190c0 <_hook_init+0x10>)
200190b8:	f04f 527c 	mov.w	r2, #1056964608	; 0x3f000000
200190bc:	601a      	str	r2, [r3, #0]
200190be:	bd08      	pop	{r3, pc}
200190c0:	20019208 	.word	0x20019208

200190c4 <_hook_process>:
void DELFX_PROCESS(float *xn, uint32_t frames)
{
  float * __restrict x = xn;
  const float * x_e = x + 2*frames;

  const float wet = s_mix;
200190c4:	4b26      	ldr	r3, [pc, #152]	; (20019160 <_hook_process+0x9c>)
  setMemory();
  s_mix = .5f;
}

void DELFX_PROCESS(float *xn, uint32_t frames)
{
200190c6:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
  {
    float curSampleL = *x;
    float curSampleR = *(x+1);
    // const float delSample1 = gain * s_delay.read0(s_len);
    // const float delSample2 = gain * s_delay.read1(s_len / 2);
    const float delSample1 = gain * delay[s_len];
200190ca:	685c      	ldr	r4, [r3, #4]
200190cc:	68de      	ldr	r6, [r3, #12]
void DELFX_PROCESS(float *xn, uint32_t frames)
{
  float * __restrict x = xn;
  const float * x_e = x + 2*frames;

  const float wet = s_mix;
200190ce:	edd3 5a00 	vldr	s11, [r3]
  {
    float curSampleL = *x;
    float curSampleR = *(x+1);
    // const float delSample1 = gain * s_delay.read0(s_len);
    // const float delSample2 = gain * s_delay.read1(s_len / 2);
    const float delSample1 = gain * delay[s_len];
200190d2:	ed93 5a02 	vldr	s10, [r3, #8]
    wetXNL = wet * delSample1;
    wetXNR = wet * delSample2;
    *x = curSampleL + wetXNL;
    *(x+1) = curSampleR + wetXNR;
    //s_delay.write(valf);
    delay[mwriteidx % BUF_SIZE] = curSampleL;
200190d6:	4f23      	ldr	r7, [pc, #140]	; (20019164 <_hook_process+0xa0>)
}

void DELFX_PROCESS(float *xn, uint32_t frames)
{
  float * __restrict x = xn;
  const float * x_e = x + 2*frames;
200190d8:	00c9      	lsls	r1, r1, #3
  {
    float curSampleL = *x;
    float curSampleR = *(x+1);
    // const float delSample1 = gain * s_delay.read0(s_len);
    // const float delSample2 = gain * s_delay.read1(s_len / 2);
    const float delSample1 = gain * delay[s_len];
200190da:	ea4f 0e84 	mov.w	lr, r4, lsl #2
    const float delSample2 = gain * delay[s_len / 2];
200190de:	0864      	lsrs	r4, r4, #1
}

void DELFX_PROCESS(float *xn, uint32_t frames)
{
  float * __restrict x = xn;
  const float * x_e = x + 2*frames;
200190e0:	eb00 0c01 	add.w	ip, r0, r1
    float curSampleL = *x;
    float curSampleR = *(x+1);
    // const float delSample1 = gain * s_delay.read0(s_len);
    // const float delSample2 = gain * s_delay.read1(s_len / 2);
    const float delSample1 = gain * delay[s_len];
    const float delSample2 = gain * delay[s_len / 2];
200190e4:	00a4      	lsls	r4, r4, #2
200190e6:	4632      	mov	r2, r6
{
  float * __restrict x = xn;
  const float * x_e = x + 2*frames;

  const float wet = s_mix;
  for (; x != x_e ; x+=2) 
200190e8:	4584      	cmp	ip, r0
200190ea:	f100 0508 	add.w	r5, r0, #8
200190ee:	f102 0802 	add.w	r8, r2, #2
200190f2:	d02f      	beq.n	20019154 <_hook_process+0x90>
    // const float delSample1 = gain * s_delay.read0(s_len);
    // const float delSample2 = gain * s_delay.read1(s_len / 2);
    const float delSample1 = gain * delay[s_len];
    const float delSample2 = gain * delay[s_len / 2];

    wetXNL = wet * delSample1;
200190f4:	edde 7a00 	vldr	s15, [lr]
    float curSampleL = *x;
    float curSampleR = *(x+1);
    // const float delSample1 = gain * s_delay.read0(s_len);
    // const float delSample2 = gain * s_delay.read1(s_len / 2);
    const float delSample1 = gain * delay[s_len];
    const float delSample2 = gain * delay[s_len / 2];
200190f8:	ed94 7a00 	vldr	s14, [r4]
  const float * x_e = x + 2*frames;

  const float wet = s_mix;
  for (; x != x_e ; x+=2) 
  {
    float curSampleL = *x;
200190fc:	ed15 6a02 	vldr	s12, [r5, #-8]
    float curSampleR = *(x+1);
20019100:	edd0 6a01 	vldr	s13, [r0, #4]
    // const float delSample1 = gain * s_delay.read0(s_len);
    // const float delSample2 = gain * s_delay.read1(s_len / 2);
    const float delSample1 = gain * delay[s_len];
    const float delSample2 = gain * delay[s_len / 2];

    wetXNL = wet * delSample1;
20019104:	ee65 7a27 	vmul.f32	s15, s10, s15
    float curSampleL = *x;
    float curSampleR = *(x+1);
    // const float delSample1 = gain * s_delay.read0(s_len);
    // const float delSample2 = gain * s_delay.read1(s_len / 2);
    const float delSample1 = gain * delay[s_len];
    const float delSample2 = gain * delay[s_len / 2];
20019108:	ee25 7a07 	vmul.f32	s14, s10, s14

    wetXNL = wet * delSample1;
2001910c:	ee67 7aa5 	vmul.f32	s15, s15, s11
    wetXNR = wet * delSample2;
20019110:	ee25 7a87 	vmul.f32	s14, s11, s14
    // const float delSample1 = gain * s_delay.read0(s_len);
    // const float delSample2 = gain * s_delay.read1(s_len / 2);
    const float delSample1 = gain * delay[s_len];
    const float delSample2 = gain * delay[s_len / 2];

    wetXNL = wet * delSample1;
20019114:	edc3 7a04 	vstr	s15, [r3, #16]
    wetXNR = wet * delSample2;
    *x = curSampleL + wetXNL;
20019118:	ee76 7a27 	vadd.f32	s15, s12, s15
    // const float delSample2 = gain * s_delay.read1(s_len / 2);
    const float delSample1 = gain * delay[s_len];
    const float delSample2 = gain * delay[s_len / 2];

    wetXNL = wet * delSample1;
    wetXNR = wet * delSample2;
2001911c:	ed83 7a05 	vstr	s14, [r3, #20]
    *x = curSampleL + wetXNL;
20019120:	ed45 7a02 	vstr	s15, [r5, #-8]
    *(x+1) = curSampleR + wetXNR;
20019124:	edd3 7a05 	vldr	s15, [r3, #20]
20019128:	ee77 7aa6 	vadd.f32	s15, s15, s13
2001912c:	edc0 7a01 	vstr	s15, [r0, #4]
    //s_delay.write(valf);
    delay[mwriteidx % BUF_SIZE] = curSampleL;
20019130:	fb92 f0f7 	sdiv	r0, r2, r7
20019134:	fb07 2010 	mls	r0, r7, r0, r2
20019138:	0080      	lsls	r0, r0, #2
    mwriteidx++;
    delay[mwriteidx % BUF_SIZE] = curSampleR;
2001913a:	3201      	adds	r2, #1
    wetXNL = wet * delSample1;
    wetXNR = wet * delSample2;
    *x = curSampleL + wetXNL;
    *(x+1) = curSampleR + wetXNR;
    //s_delay.write(valf);
    delay[mwriteidx % BUF_SIZE] = curSampleL;
2001913c:	ed80 6a00 	vstr	s12, [r0]
    mwriteidx++;
    delay[mwriteidx % BUF_SIZE] = curSampleR;
20019140:	fb92 f0f7 	sdiv	r0, r2, r7
20019144:	fb07 2210 	mls	r2, r7, r0, r2
20019148:	0092      	lsls	r2, r2, #2
2001914a:	edc2 6a00 	vstr	s13, [r2]
{
  float * __restrict x = xn;
  const float * x_e = x + 2*frames;

  const float wet = s_mix;
  for (; x != x_e ; x+=2) 
2001914e:	4628      	mov	r0, r5
20019150:	4642      	mov	r2, r8
20019152:	e7c9      	b.n	200190e8 <_hook_process+0x24>
20019154:	eb06 0191 	add.w	r1, r6, r1, lsr #2
20019158:	60d9      	str	r1, [r3, #12]
2001915a:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
2001915e:	bf00      	nop
20019160:	20019208 	.word	0x20019208
20019164:	00033450 	.word	0x00033450

20019168 <_hook_param>:
    mwriteidx++;
  }
}

void DELFX_PARAM(uint8_t index, int32_t value)
{
20019168:	b508      	push	{r3, lr}
2001916a:	ed2d 8b02 	vpush	{d8}
  const float valf = q31_to_f32(value);
2001916e:	ee08 1a10 	vmov	s16, r1
  switch (index) 
20019172:	2801      	cmp	r0, #1
  }
}

void DELFX_PARAM(uint8_t index, int32_t value)
{
  const float valf = q31_to_f32(value);
20019174:	eeba 8ae0 	vcvt.f32.s32	s16, s16, #31
  switch (index) 
20019178:	d00a      	beq.n	20019190 <_hook_param+0x28>
2001917a:	d305      	bcc.n	20019188 <_hook_param+0x20>
2001917c:	2803      	cmp	r0, #3
2001917e:	d135      	bne.n	200191ec <_hook_param+0x84>
      s_len = ((60 * 48000) / bpm) / 2;
    }
    break;
  case 3:
    // Mix Val
    s_mix = valf;
20019180:	4b1c      	ldr	r3, [pc, #112]	; (200191f4 <_hook_param+0x8c>)
20019182:	ed83 8a00 	vstr	s16, [r3]
    break;
  default:
    break;
  }
20019186:	e031      	b.n	200191ec <_hook_param+0x84>
  const float valf = q31_to_f32(value);
  switch (index) 
  {
  case 0:
    // Gain == Feedback //
    gain = valf;
20019188:	4b1a      	ldr	r3, [pc, #104]	; (200191f4 <_hook_param+0x8c>)
2001918a:	ed83 8a02 	vstr	s16, [r3, #8]
    break;
2001918e:	e02d      	b.n	200191ec <_hook_param+0x84>
  case 1:

    bpm = _fx_get_bpm() / 10;
20019190:	f000 f836 	bl	20019200 <___fx_get_bpm_veneer>
    // Calculate note intervals
    if (valf < 0.25) 
20019194:	eef5 7a00 	vmov.f32	s15, #80	; 0x3e800000  0.250
    // Gain == Feedback //
    gain = valf;
    break;
  case 1:

    bpm = _fx_get_bpm() / 10;
20019198:	230a      	movs	r3, #10
    // Calculate note intervals
    if (valf < 0.25) 
2001919a:	eeb4 8ae7 	vcmpe.f32	s16, s15
    // Gain == Feedback //
    gain = valf;
    break;
  case 1:

    bpm = _fx_get_bpm() / 10;
2001919e:	fbb0 f0f3 	udiv	r0, r0, r3
200191a2:	4b14      	ldr	r3, [pc, #80]	; (200191f4 <_hook_param+0x8c>)
200191a4:	b280      	uxth	r0, r0
    // Calculate note intervals
    if (valf < 0.25) 
200191a6:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
    // Gain == Feedback //
    gain = valf;
    break;
  case 1:

    bpm = _fx_get_bpm() / 10;
200191aa:	6198      	str	r0, [r3, #24]
    // Calculate note intervals
    if (valf < 0.25) 
200191ac:	d505      	bpl.n	200191ba <_hook_param+0x52>
    {
      // Full note
      s_len = ((60 * 48000) / bpm) * 4;
200191ae:	4a12      	ldr	r2, [pc, #72]	; (200191f8 <_hook_param+0x90>)
200191b0:	fb92 f0f0 	sdiv	r0, r2, r0
200191b4:	0080      	lsls	r0, r0, #2
200191b6:	6058      	str	r0, [r3, #4]
200191b8:	e018      	b.n	200191ec <_hook_param+0x84>
    } 
    else if (valf < 0.5) 
200191ba:	eef6 7a00 	vmov.f32	s15, #96	; 0x3f000000  0.5
200191be:	eeb4 8ae7 	vcmpe.f32	s16, s15
200191c2:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
200191c6:	d505      	bpl.n	200191d4 <_hook_param+0x6c>
    {
      // 1/2 note
      s_len = ((60 * 48000) / bpm) * 2;
200191c8:	4a0b      	ldr	r2, [pc, #44]	; (200191f8 <_hook_param+0x90>)
200191ca:	fb92 f0f0 	sdiv	r0, r2, r0
200191ce:	0040      	lsls	r0, r0, #1
200191d0:	6058      	str	r0, [r3, #4]
200191d2:	e00b      	b.n	200191ec <_hook_param+0x84>
    } 
    else if (valf < 0.75) 
200191d4:	eef6 7a08 	vmov.f32	s15, #104	; 0x3f400000  0.750
200191d8:	eeb4 8ae7 	vcmpe.f32	s16, s15
200191dc:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
    {
      // 1/4 note
      s_len = ((60 * 48000) / bpm);
200191e0:	bf4c      	ite	mi
200191e2:	4a05      	ldrmi	r2, [pc, #20]	; (200191f8 <_hook_param+0x90>)
    } 
    else 
    {
      // 1/8 note
      s_len = ((60 * 48000) / bpm) / 2;
200191e4:	4a05      	ldrpl	r2, [pc, #20]	; (200191fc <_hook_param+0x94>)
200191e6:	fb92 f0f0 	sdiv	r0, r2, r0
200191ea:	6058      	str	r0, [r3, #4]
    s_mix = valf;
    break;
  default:
    break;
  }
200191ec:	ecbd 8b02 	vpop	{d8}
200191f0:	bd08      	pop	{r3, pc}
200191f2:	bf00      	nop
200191f4:	20019208 	.word	0x20019208
200191f8:	002bf200 	.word	0x002bf200
200191fc:	0015f900 	.word	0x0015f900

20019200 <___fx_get_bpm_veneer>:
20019200:	f85f f000 	ldr.w	pc, [pc]	; 20019204 <___fx_get_bpm_veneer+0x4>
20019204:	0807ca89 	.word	0x0807ca89
